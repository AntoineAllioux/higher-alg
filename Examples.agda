{-# OPTIONS --without-K --rewriting --type-in-type #-}

open import HoTT
open import Util
open import Polynomial
open import Substitution
open import SubstCoh
open import PolyMonad

module Examples where

  ùïå : Poly ‚ä§
  Œ≥ ùïå unit = Type‚ÇÄ
  œÅ ùïå X unit = X

  -- BDDomain : {I : Type‚ÇÄ} (P : Poly I)
  --   ‚Üí (Œº : {i : I} (w : W P i) ‚Üí Œ≥ P i)
  --   ‚Üí (œï : {i : I} (w : W P i) ‚Üí Frame P w (Œº w))
  --   ‚Üí (Œ± : (F : FillingFamily P) {i : I} {c : Œ≥ P i} (pd : W (P // F) (i , c))
  --     ‚Üí Path {A = Œ£ (Œ≥ P i) (Œª c‚ÇÄ ‚Üí Frame P (flatten F pd) c‚ÇÄ)}
  --       (c , flatten-frm F pd) (Œº (flatten F pd) , œï (flatten F pd)))
  --   ‚Üí PolyDomain P
  -- F (BDDomain P Œº œï Œ±) w c f = (c , f) == (Œº w , œï w)
  -- H (BDDomain P Œº œï Œ±) = BDDomain (P // (Œª w c f ‚Üí (c , f) == (Œº w , œï w)))
  --   (Œª { {i , c} pd ‚Üí flatten (Œª w c f ‚Üí (c , f) == (Œº w , œï w)) pd ,
  --                     flatten-frm (Œª w c f ‚Üí (c , f) == (Œº w , œï w)) pd ,
  --                     Œ± (Œª w c f ‚Üí (c , f) == (Œº w , œï w)) pd })
  --   (Œª pd ‚Üí bd-frame (Œª w c f ‚Üí (c , f) == (Œº w , œï w)) pd)
  --   Œª { F {i , .(Œº w)} {w , .(œï w) , idp} pd ‚Üí {!!} }

  module _ {I : Type‚ÇÄ} (P : Poly I)
    (is-f : {i : I} (w : W P i) ‚Üí is-contr (Œ£ (Œ≥ P i) (Frame P w))) where

    CF : FillingFamily P
    CF w c f = contr-center (is-f w) == (c , f) 

    claim‚ÇÄ : {ic : Œ£ I (Œ≥ P)} (pd : W (P // CF) ic) ‚Üí Œ£ (Œ≥ (P // CF) ic) (Frame (P // CF) pd)
    claim‚ÇÄ {i , c} pd = (flatten CF pd , flatten-frm CF pd , contr-path (is-f (flatten CF pd)) (c , flatten-frm CF pd)) , bd-frame CF pd

    claim‚ÇÅ : {ic : Œ£ I (Œ≥ P)} (pd : W (P // CF) ic)
      ‚Üí (Œ± : Œ£ (Œ≥ (P // CF) ic) (Frame (P // CF) pd))
      ‚Üí claim‚ÇÄ pd == Œ±
    claim‚ÇÅ (lf (i , ._)) ((w , ._ , idp) , s) = pair= {!!} {!!}
    claim‚ÇÅ (nd {i , c} ((w , f , x) , Œ∫)) Œ± = {!!}

  --   claim : {ic : Œ£ I (Œ≥ P)} (pd : W (P // CF) ic) ‚Üí is-contr (Œ£ (Œ≥ (P // CF) ic) (Frame (P // CF) pd))
  --   claim {i , c} pd = has-level-in (ctr , pth)

  --     where ctr : Œ£ (Œ£ (W P i) (Œª w ‚Üí Œ£ (Frame P w c) (CF w c))) (Frame (P // CF) pd)
  --           ctr = (flatten CF pd , flatten-frm CF pd , contr-path (is-f (flatten CF pd)) (c , flatten-frm CF pd)) , bd-frame CF pd

  --           pth : (Œ± : Œ£ (Œ£ (W P i) (Œª w ‚Üí Œ£ (Frame P w c) (CF w c))) (Frame (P // CF) pd)) ‚Üí ctr == Œ±
  --           pth ((w , cf , r) , sf) = {!!}

    -- What do we know at this point?  We know that c
    -- is the multipled object and the frame is the chosen one.

    -- Now, we have this pasting diagram and a frame which
    -- witnesses that the nodes of the flattened tree are w's
    -- and the output frame is the right one and so on.

    -- But I don't think this will be enough.  Yes, indeed.
    -- This says nothing about the outside frame and w and so on.



  -- Let's rephrase.  Suppose you don't give me Œº and œï,
  -- but rather a proof that they are contractible.  Then
  -- I have this guy for free, no?
  -- BDDomain : {I : Type‚ÇÄ} (P : Poly I)
  --   ‚Üí (is-f : {i : I} (w : W P i) ‚Üí is-contr (Œ£ (Œ≥ P i) (Frame P w)))
  --   ‚Üí PolyDomain P
  -- F (BDDomain P is-f) w c f = contr-center (is-f w) == (c , f) 
  -- H (BDDomain P is-f) = BDDomain (P // (Œª w c f ‚Üí contr-center (is-f w) == (c , f))) (claim P is-f)

  -- module _ {I : Type‚ÇÄ} (P : Poly I)
  --   (Œº : {i : I} (w : W P i) ‚Üí Œ≥ P i)
  --   (œï : {i : I} (w : W P i) ‚Üí Frame P w (Œº w)) where

  --   CF : FillingFamily P
  --   CF w c f = (c , f) == (Œº w , œï w)

  --   -- What is contractible with this definition?
  --   cmp-contr : {i : I} (w : W P i) ‚Üí is-contr (CompositeFor CF w)
  --   cmp-contr w = has-level-in (ctr , pth)

  --     where ctr : CompositeFor CF w
  --           ctr = Œº w , œï w , idp

  --           pth : (cmp : CompositeFor CF w) ‚Üí ctr == cmp
  --           pth (.(Œº w) , .(œï w) , idp) = idp
            
    -- Yes, that's right.  So you were, in a sense, trying to
    -- show the wrong thing above.
  
  MFam : {I : Type‚ÇÄ} (P : Poly I)
    ‚Üí (m : {i : I} (w : W P i) ‚Üí Œ£ (Œ≥ P i) (Frame P w))
    ‚Üí FillingFamily P
  MFam P m w c f = m w == (c , f)
  
  record MultOp {I : Type‚ÇÄ} (P : Poly I) : Type‚ÇÄ where
    field

      m : {i : I} (w : W P i) ‚Üí Œ£ (Œ≥ P i) (Frame P w)
      
      unit-m : {i : I} {c : Œ≥ P i}
        ‚Üí  m (corolla P c) == (c , flatten-frm (MFam P m) (lf (i , c))) 

      assoc-m : {i : I} {w : W P i}
        ‚Üí (Œ∫ : (ic : Œ£ I (Œ≥ P)) ‚Üí Node P w (snd ic) ‚Üí W (P // MFam P m) ic)
        ‚Üí m (substitute (MFam P m) w Œ∫) == (fst (m w) , flatten-frm (MFam P m) (nd ((w , snd (m w) , idp) , Œ∫))) 


  open MultOp


  
  -- Uh-oh, that didn't quite come out like I expected.  It looks
  -- unfortunately, like we are being asked for another coherence.
  -- Hmmm.
  module _ {I : Type‚ÇÄ} (P : Poly I) (op : MultOp P) where

    Fm = MFam P (m op)
  
    lem : {i : I} {c : Œ≥ P i} (pd : W (P // Fm) (i , c))
      ‚Üí Path {A = Œ£ (Œ≥ P i) (Œª c‚ÇÄ ‚Üí Frame P (flatten Fm pd) c‚ÇÄ)}
        (m op (flatten Fm pd)) (c , flatten-frm Fm pd) 
    lem (lf (i , c)) = unit-m op
    lem (nd ((w , ._ , idp) , Œ∫)) = assoc-m op Œ∫

    thm : MultOp (P // MFam P (m op))
    m thm w = (flatten Fm w , flatten-frm Fm w , lem w) , bd-frame Fm w
    unit-m thm {i , .(fst (m op w))} {w , .(snd (m op w)) , idp} = {!!} 
      -- pair= (pair= (substitute-unit Fm w) (‚Üì-Œ£-in (substitute-unit-frm Fm w (fst (m op w)) (snd (m op w)) idp) (‚Üì-=-in {!!}))) {!!} 
    assoc-m thm {w = lf (i , c)} Œ∫ = pair= idp {!!}
    assoc-m thm {w = nd ((w‚ÇÄ , .(snd (m op w‚ÇÄ)) , idp) , Œ¥)} Œ∫ = pair= (pair= {!!} {!!}) {!!}


  -- EQFamily : {I : Type‚ÇÄ} (P : Poly I)
  --   ‚Üí (Œº : {i : I} (w : W P i) ‚Üí Œ≥ P i)
  --   ‚Üí (œï : {i : I} (w : W P i) ‚Üí Frame P w (Œº w))
  --   ‚Üí FillingFamily P
  -- EQFamily P Œº œï w c f = (Œº w , œï w) == (c , f)

  -- module _ {I : Type‚ÇÄ} (P : Poly I)
  --   (Œº : {i : I} (w : W P i) ‚Üí Œ≥ P i)
  --   (œï : {i : I} (w : W P i) ‚Üí Frame P w (Œº w))
  --   (unit-law : {i : I} {c : Œ≥ P i} ‚Üí (c , flatten-frm (EQFamily P Œº œï) (lf (i , c))) == (Œº (corolla P c) , œï (corolla P c)))
  --   (assoc-law : {i : I} {w : W P i}
  --     ‚Üí (Œ∫ : (ic : Œ£ I (Œ≥ P)) ‚Üí Node P w (snd ic) ‚Üí W (P // (EQFamily P Œº œï)) ic)
  --     ‚Üí (Œº w , flatten-frm (EQFamily P Œº œï) (nd ((w , œï w , idp) , Œ∫))) == (Œº (substitute (EQFamily P Œº œï) w Œ∫) , œï (substitute (EQFamily P Œº œï) w Œ∫)))
  --   where

  --   CF = EQFamily P Œº œï
    
  --   -- In other words, we can reduce the previous assumption
  --   -- to saying that Œº preserves the corolla and substitution
  --   -- and that œï is compatible with that.
  --   lemma : {i : I} {c : Œ≥ P i} (pd : W (P // CF) (i , c))
  --     ‚Üí Path {A = Œ£ (Œ≥ P i) (Œª c‚ÇÄ ‚Üí Frame P (flatten CF pd) c‚ÇÄ)}
  --       (c , flatten-frm CF pd) (Œº (flatten CF pd) , œï (flatten CF pd))
  --   lemma (lf (i , c)) = unit-law
  --   lemma (nd {i , .(Œº w)} ((w , .(œï w) , idp) , s)) = assoc-law s

  --   Œº‚ÇÅ : {ic : Œ£ I (Œ≥ P)} (pd : W (P // CF) ic) ‚Üí Œ≥ (P // CF) ic
  --   Œº‚ÇÅ {i , c} pd = flatten CF pd , flatten-frm CF pd , ! (lemma pd)

  --   œï‚ÇÅ : {ic : Œ£ I (Œ≥ P)} (pd : W (P // CF) ic) ‚Üí Frame (P // CF) pd (Œº‚ÇÅ pd)
  --   œï‚ÇÅ {i , c} pd = bd-frame CF pd

  --   -- Yeah, it's funny.  If you apply the substitution unit to the assoc law above,
  --   -- it seems like the two actually do get linked and that the path over,
  --   -- which will be composition, might just link them up.  So surprisingly,
  --   -- this does not look completely hopeless.
  --   unit-law‚ÇÅ : {ic : Œ£ I (Œ≥ P)} {cc : Œ≥ (P // CF) ic}
  --     ‚Üí Path {A = Œ£ (Œ≥ (P // CF) ic) (Frame (P // CF) (corolla (P // CF) cc))}
  --       (cc , flatten-frm (EQFamily (P // CF) Œº‚ÇÅ œï‚ÇÅ) (lf (ic , cc))) (Œº‚ÇÅ (corolla (P // CF) cc) , œï‚ÇÅ (corolla (P // CF) cc))
  --   unit-law‚ÇÅ {i , .(Œº w)} {w , .(œï w) , idp} = pair= (pair= (substitute-unit CF w) (‚Üì-Œ£-in {!!} {!!})) {!!}

  -- Okay, interesting.  So I'm being asked, as I expected, for some
  -- compatibility with bd.  That is, if I multiply a flattened tree,
  -- who had, for output, c, then I still get c.  And moreover, that
  -- when I calculate the frame of such a thing, it is the same as
  -- the canonical frame given by flattening.

  -- Okay, and the thing is, I guess it is important that this *not*
  -- depend on the filling family.  Nice.  This is actually pretty
  -- interesting.  The point is that, one way to have a coherent
  -- structure would be for it to work for *any* filling family.
  -- And the canonical example of such a thing is baez-dolan
  -- subsitution itself.

  -- -- ùïå-Family : FillingFamily ùïå
  -- -- ùïå-Family w X f = ‚ä§

  -- -- TermFamily : {I : Type‚ÇÄ} (P : Poly I) ‚Üí FillingFamily P
  -- -- TermFamily P w c f = ‚ä§

  -- -- module _ {I : Type‚ÇÄ} (P : Poly I)
  -- --   -- (is-f : {i : I} (w : W P i) ‚Üí is-contr (CompositeFor (TermFamily P) w))
  -- --   (is-c : {i : I} {c : Œ≥ P i} (pd : W (P // TermFamily P) (i , c)) ‚Üí
  -- --     is-equiv (CoherenceToComposite (TermFamily (P // TermFamily P)) pd)) where

  -- --   conj : {ic : Œ£ I (Œ≥ P)} (pd : W (P // TermFamily P) ic) ‚Üí is-contr (CompositeFor (TermFamily (P // TermFamily P)) pd)
  -- --   conj {i , c} pd = has-level-in (ctr , pth)

  -- --     where ctr : CompositeFor (TermFamily (P // TermFamily P)) pd
  -- --           ctr = (flatten (TermFamily P) pd , flatten-frm (TermFamily P) pd , unit) , bd-frame (TermFamily P) pd , unit

  -- --           pth : (cmp : CompositeFor (TermFamily (P // TermFamily P)) pd) ‚Üí ctr == cmp
  -- --           pth ((w , f , unit) , ff , unit) = is-equiv.f-g (is-c pd) ((w , f , unit) , ff , unit)
    
  -- --   conj‚ÇÄ : {ic : Œ£ I (Œ≥ P)} {cc : Œ≥ (P // TermFamily P) ic} (coh : W ((P // TermFamily P) // TermFamily (P // TermFamily P)) (ic , cc))
  -- --     ‚Üí is-contr (CoherenceFor (TermFamily ((P // TermFamily P) // TermFamily (P // TermFamily P))) coh)
  -- --   conj‚ÇÄ {i , c} {w , f , unit} coh = has-level-in (ctr , Œª _ ‚Üí idp)

  -- --     where ctr : CoherenceFor (TermFamily ((P // TermFamily P) // TermFamily (P // TermFamily P))) coh
  -- --           ctr = tt , tt
            
  -- --   crazy : {ic : Œ£ I (Œ≥ P)} {cc : Œ≥ (P // TermFamily P) ic} (coh : W ((P // TermFamily P) // TermFamily (P // TermFamily P)) (ic , cc))
  -- --     ‚Üí is-equiv (CoherenceToComposite (TermFamily ((P // TermFamily P) // TermFamily (P // TermFamily P))) coh)
  -- --   crazy coh = any-contr-eqv (conj‚ÇÄ coh) {!!} _
            
  -- module _ {I : Type‚ÇÄ} {P : Poly I} (F : FillingFamily P)
  --   {i : I} {c : Œ≥ P i} (pd : W (P // F) (i , c)) 
  --   (w : W P i) (f : Frame P w c) (x : F w c f) (ff : Frame (P // F) pd (w , f , x)) where

  --   tx : (wp : w == flatten F pd)
  --     ‚Üí (fp : f == flatten-frm F pd [ (Œª w‚ÇÄ ‚Üí Frame P w‚ÇÄ c) ‚Üì wp ])
  --     ‚Üí F (flatten F pd) c (flatten-frm F pd)
  --   tx idp idp = x 

  --   finally : (wp : w == flatten F pd)
  --     ‚Üí (fp : f == flatten-frm F pd [ (Œª w‚ÇÄ ‚Üí Frame P w‚ÇÄ c) ‚Üì wp ])
  --     ‚Üí Path {A = Œ£ (W P i) (Œª w‚ÇÄ ‚Üí Œ£ (Frame P w‚ÇÄ c) (Œª f‚ÇÄ ‚Üí F w‚ÇÄ c f‚ÇÄ))}
  --            (w , f , x) (flatten F pd , flatten-frm F pd , tx wp fp)
  --   finally idp idp = idp

  --   record CanonicalFiller  : Type‚ÇÄ where
  --     constructor cf
  --     field

  --       w-pth : w == flatten F pd
  --       f-pth : f == flatten-frm F pd [ (Œª w‚ÇÄ ‚Üí Frame P w‚ÇÄ c) ‚Üì w-pth ]
  --       ff-pth : ff == bd-frame F pd [ (Œª { (w‚ÇÄ , f‚ÇÄ , x‚ÇÄ) ‚Üí Frame (P // F) pd (w‚ÇÄ , f‚ÇÄ , x‚ÇÄ) }) ‚Üì finally w-pth f-pth ] 

  -- CanonicalFamily : {I : Type‚ÇÄ} {P : Poly I} (F : FillingFamily P)
  --  ‚Üí FillingFamily (P // F)
  -- CanonicalFamily F {i , c} pd (w , f , x) = CanonicalFiller F pd w f x

  -- module _ {I : Type‚ÇÄ} (P : Poly I) where

  --   claim : {ic : Œ£ I (Œ≥ P)} (pd : W (P // TermFamily P) ic) ‚Üí is-contr (CompositeFor (CanonicalFamily (TermFamily P)) pd)
  --   claim {i , c} pd = has-level-in (ctr , pth)

  --     where ctr : CompositeFor (CanonicalFamily (TermFamily P)) pd
  --           ctr = (flatten (TermFamily P) pd , flatten-frm (TermFamily P) pd , unit) , bd-frame (TermFamily P) pd , cf idp idp idp

  --           pth : (cmp : CompositeFor (CanonicalFamily (TermFamily P)) pd) ‚Üí ctr == cmp
  --           pth ((.(flatten  (TermFamily P) pd) , .(flatten-frm (TermFamily P) pd) , unit) , .(bd-frame (TermFamily P) pd) , cf idp idp idp) = idp


  --   next : {idx : Œ£ (Œ£ I (Œ≥ P)) (Œ≥ (P // TermFamily P))} (pd : W ((P // TermFamily P) // CanonicalFamily (TermFamily P)) idx)
  --     ‚Üí is-contr (CompositeFor (CanonicalFamily (CanonicalFamily (TermFamily P))) pd)
  --   next {(i , c) , (w , f , unit)} pd = has-level-in (ctr , pth)

  --     where ctr : CompositeFor (CanonicalFamily (CanonicalFamily (TermFamily P))) pd
  --           ctr = (flatten (CanonicalFamily (TermFamily P)) pd , flatten-frm (CanonicalFamily (TermFamily P)) pd , cf {!!} {!!} {!!}) ,
  --                 bd-frame (CanonicalFamily (TermFamily P)) pd , cf idp idp idp

  --           pth : (cmp : CompositeFor (CanonicalFamily (CanonicalFamily (TermFamily P))) pd) ‚Üí ctr == cmp
  --           pth ((._ , ._ , ccc) , ._ , cf idp idp idp) = {!c!}

  --   -- Yeah, so it looks like what you need is that other axiom to "inhabit" as it were
  --   -- the coherence type based on these compositions, find that they are equal since
  --   -- that type is contractible, then apply this equality to the inclusion function.

  --   -- You kind of saw this idea before.  So like, probably you need to define the two in
  --   -- parallel, but I'm a bit concerned because, like, it doesn't look, a priori, like the
  --   -- cohernce type is contractible.  But of course, your axioms imply that it ought to be.

  --   -- On the other hand, here you work with a generic polynomial, wheras you expect to
  --   -- prove this is special cases.  In particular, the terminal guy rarely should have
  --   -- a contractible multiplication, so ....
    
  --   -- Yup, exactly.  What about the coherences are they contractible?

  --   maybe : {i : I} {c : Œ≥ P i} (pd : W (P // TermFamily P) (i , c))
  --     ‚Üí is-contr (CoherenceFor (CanonicalFamily (TermFamily P)) pd)
  --   maybe pd = has-level-in (ctr , {!!})

  --     where ctr : CoherenceFor (CanonicalFamily (TermFamily P)) pd
  --           ctr = tt , cf idp idp idp

  --           pth : (coh : CoherenceFor (CanonicalFamily (TermFamily P)) pd) ‚Üí tt , cf idp idp idp == coh
  --           pth (tt , cf w-pth f-pth ff-pth) = {!!}


  --   -- No!  So we cannot somehow just repeat.
  --   -- But then is this a problem?  Like, is there
  --   -- something wrong with your definition or something?

  --   -- Well, I mean, you could try to see if the *next* guy works too, just to
  --   -- see if there is a pattern....


  -- -- CoherenceToComposite : {I : Type‚ÇÄ} {P : Poly I} {F : FillingFamily P} (FF : FillingFamily (P // F))
  -- --  {i : I} {c : Œ≥ P i} (pd : W (P // F) (i , c))
  -- --  ‚Üí CoherenceFor FF pd ‚Üí CompositeFor FF pd
  -- -- CoherenceToComposite {P = P} {F} FF pd (f‚ÇÄ , f‚ÇÅ) =
  -- --   (flatten F pd , flatten-frm F pd , f‚ÇÄ) , bd-frame F pd , f‚ÇÅ


  -- -- CoherenceFor : {I : Type‚ÇÄ} {P : Poly I} {F : FillingFamily P} (FF : FillingFamily (P // F))
  -- --   {i : I} {c : Œ≥ P i} (pd : W (P // F) (i , c)) ‚Üí Type‚ÇÄ
  -- -- CoherenceFor {P = P} {F} FF {c = c} pd = Œ£ (F (flatten F pd) c (flatten-frm F pd))
  -- --   (Œª f ‚Üí FF pd (flatten F pd , flatten-frm F pd , f) (bd-frame F pd))


  -- -- module _ {I : Type‚ÇÄ} {P : Poly I} (F : FillingFamily P)
  -- --   (is-c : {i : I} {c : Œ≥ P i} (pd : W (P // F) (i , c)) ‚Üí is-contr (CoherenceFor (CanonicalFamily F) pd)) where

  -- --   -- Okay, this seems like progress because we no longer have a completely arbitrary
  -- --   -- section running around that we have to be compatible with.  It seems that the
  -- --   -- equations are completely general coherences related to the Baez-Dolan construction.
  -- --   conj : {ic : Œ£ I (Œ≥ P)} {cc : Œ≥ (P // F) ic} (coh : W ((P // F) // CanonicalFamily F) (ic , cc))
  -- --     ‚Üí is-contr (CoherenceFor (CanonicalFamily (CanonicalFamily F)) coh)
  -- --   conj {i , c} {w , f , x} (lf .((i , c) , w , f , x)) = has-level-in ({!!} , {!!})

  -- --     where ctr : CoherenceFor (CanonicalFamily (CanonicalFamily F)) (lf ((i , c) , w , f , x))
  -- --           ctr = (cf (substitute-unit F w) {!!} {!!}) , (cf idp idp idp)

  -- --           pth : (coh : CoherenceFor (CanonicalFamily (CanonicalFamily F)) (lf ((i , c) , w , f , x)))
  -- --             ‚Üí ctr == coh
  -- --           pth (f‚ÇÄ , cf w-pth f-pth ff-pth) = {!!}
                    
  -- --     -- has-level-in (((cf (substitute-unit F w) {!!} {!!}) , (cf idp idp idp)) , {!!})
  -- --   conj {i , c} {.(flatten F pd) , .(flatten-frm F pd) , x} (nd ((pd , .(bd-frame F pd) , cf idp idp idp) , sf)) =
  -- --     has-level-in (((cf {!!} {!!} {!!}) , (cf idp idp idp)) , {!!})


  -- -- -- Right, interesting.  So then, doesn't it seem like this map ought to be
  -- -- -- an equivalence?  And then, if that's the case, wouldn't a proof that this
  -- -- -- was contractible finish the job?
  -- -- CanonicalInverse : {I : Type‚ÇÄ} {P : Poly I} (F : FillingFamily P)
  -- --   ‚Üí {i : I} {c : Œ≥ P i} (pd : W (P // F) (i , c))
  -- --   ‚Üí CompositeFor (CanonicalFamily F) pd ‚Üí CoherenceFor (CanonicalFamily F) pd
  -- -- CanonicalInverse F pd ((.(flatten F pd) , .(flatten-frm F pd) , x) , .(bd-frame F pd) , cf idp idp idp) =
  -- --   x , cf idp idp idp

  -- -- CanonicalToFrom : {I : Type‚ÇÄ} {P : Poly I} (F : FillingFamily P)
  -- --   ‚Üí {i : I} {c : Œ≥ P i} (pd : W (P // F) (i , c))
  -- --   ‚Üí (cmp : CompositeFor (CanonicalFamily F) pd)
  -- --   ‚Üí CoherenceToComposite (CanonicalFamily F) pd (CanonicalInverse F pd cmp) == cmp
  -- -- CanonicalToFrom F pd ((.(flatten F pd) , .(flatten-frm F pd) , x) , .(bd-frame F pd) , cf idp idp idp) = idp

  -- -- -- So here we get stuck.  However, if we assume the coherences were contractible,
  -- -- -- then we would finish.  And that would imply the uniqueness of composites in the
  -- -- -- next dimension.  And we would be left to prove that this property was inherited
  -- -- -- by the next canonical family ...
  -- -- CanonicalFromTo : {I : Type‚ÇÄ} {P : Poly I} (F : FillingFamily P)
  -- --   ‚Üí {i : I} {c : Œ≥ P i} (pd : W (P // F) (i , c))
  -- --   ‚Üí (coh : CoherenceFor (CanonicalFamily F) pd)
  -- --   ‚Üí CanonicalInverse F pd (CoherenceToComposite (CanonicalFamily F) pd coh) == coh
  -- -- CanonicalFromTo F pd (x , cf w-pth f-pth ff-pth) = {!!}


  -- -- -- CoherenceFor : {I : Type‚ÇÄ} {P : Poly I} {F : FillingFamily P} (FF : FillingFamily (P // F))
  -- -- --   {i : I} {c : Œ≥ P i} (pd : W (P // F) (i , c)) ‚Üí Type‚ÇÄ
  -- -- -- CoherenceFor {P = P} {F} FF {c = c} pd = Œ£ (F (flatten F pd) c (flatten-frm F pd))
  -- -- --   (Œª f ‚Üí FF pd (flatten F pd , flatten-frm F pd , f) (bd-frame F pd))

  -- -- -- CanonicalHasFillers : {I : Type‚ÇÄ} {P : Poly I} (F : FillingFamily P)
  -- -- --   ‚Üí (is-f : {i : I} (w : W P i) ‚Üí is-contr (CompositeFor F w))
  -- -- --   ‚Üí (is-c : {i : I} {c : Œ≥ P i} (pd : W (P // F) (i , c)) ‚Üí is-contr (CoherenceFor (CanonicalFamily F) pd))
  -- -- --   ‚Üí {ic : Œ£ I (Œ≥ P)} (pd : W (P // F) ic) ‚Üí is-contr (CompositeFor (CanonicalFamily F) pd)
  -- -- -- CanonicalHasFillers F is-f is-c pd = has-level-in ({!!} , {!!})

  -- -- --   where ctr : CompositeFor (CanonicalFamily F) pd
  -- -- --         ctr = (flatten F pd , flatten-frm F pd , {!!}) , bd-frame F pd , cf idp idp idp

  -- -- --         pth : (x : CompositeFor (CanonicalFamily F) pd) ‚Üí ctr == x
  -- -- --         pth ((._ , ._ , x) , ._ , (cf idp idp idp)) = {!!}

  -- -- -- -- frame-and-target : {I : Type‚ÇÄ} {P : Poly I} (F : FillingFamily P)
  -- -- -- --   ‚Üí (is-f : {i : I} (w : W P i) ‚Üí is-contr (CompositeFor F w))
  -- -- -- --   ‚Üí {i : I} (w : W P i) ‚Üí Œ£ (Œ≥ P i) (Frame P w)
  -- -- -- -- frame-and-target F is-f w = let cmp = contr-center (is-f w) in fst cmp , fst (snd cmp)

  -- -- -- -- module _ {I : Type‚ÇÄ} {P : Poly I} (F : FillingFamily P)
  -- -- -- --   (is-f : {i : I} (w : W P i) ‚Üí is-contr (CompositeFor F w))
  -- -- -- --   (hyp : {i : I} {c : Œ≥ P i} (pd : W (P // F) (i , c))
  -- -- -- --       ‚Üí frame-and-target F is-f (flatten F pd) == c , flatten-frm F pd) where

  -- -- -- --   filler : {i : I} {c : Œ≥ P i} (pd : W (P // F) (i , c)) ‚Üí F (flatten F pd) c (flatten-frm F pd)
  -- -- -- --   filler pd = transport (Œª pr ‚Üí F (flatten F pd) (fst pr) (snd pr)) (hyp pd) (snd (snd (contr-center (is-f (flatten F pd)))))

  -- -- -- --   path-family : FillingFamily (P // F)
  -- -- -- --   path-family {i , c} pd (w , f , x) ff =
  -- -- -- --     Path {A = Œ£ (Œ£ (W P i) (Œª w‚ÇÄ ‚Üí Œ£ (Frame P w‚ÇÄ c) (F w‚ÇÄ c))) (Frame (P // F) pd) }
  -- -- -- --       ((w , f , x) , ff)
  -- -- -- --       ((flatten F pd , flatten-frm F pd , filler pd) , bd-frame F pd)

  -- -- -- --   path-is-f : {ic : Œ£ I (Œ≥ P)} (pd : W (P // F) ic) ‚Üí is-contr (CompositeFor path-family pd)
  -- -- -- --   path-is-f {i , c} pd = has-level-in (ctr , pth) 
  
  -- -- -- --     where ctr : CompositeFor path-family pd
  -- -- -- --           ctr = ((flatten F pd , flatten-frm F pd , filler pd) , bd-frame F pd , idp)

  -- -- -- --           pth : (coh : CompositeFor path-family pd) ‚Üí ctr == coh
  -- -- -- --           pth (.(flatten F pd , flatten-frm F pd , filler pd) , .(bd-frame F pd) , idp) = idp

  -- -- -- --   conj : {ic : Œ£ I (Œ≥ P)} {flr : Œ≥ (P // F) ic} (coh : W ((P // F) // path-family) (ic , flr))
  -- -- -- --     ‚Üí frame-and-target path-family path-is-f (flatten path-family coh)
  -- -- -- --       == flr , flatten-frm path-family coh
  -- -- -- --   conj {i , c} {w , f , x} (lf .((i , c) , w , f , x)) = pair= (pair= {!!} {!!}) {!!}
  -- -- -- --   conj {i , c} {.(flatten F pd) , .(flatten-frm F pd) , .(filler pd)} (nd ((pd , .(bd-frame F pd) , idp) , sfrm)) = {!!}

  -- -- --   -- So, it seems we still end up with a proof to do by induction.
  -- -- --   -- Mmmm.  So maybe your previous formulation is in fact simpler,
  -- -- --   -- as it does not require this extra equality ...

  -- -- --   -- Indeed, in the current formulation, it appears that we are asked to prove a
  -- -- --   -- number of (pretty reasonable) equalities, that is, coherences about the baez-dolan
  -- -- --   -- construction.  I think these two forumations are basically equivalent: in the other
  -- -- --   -- formulation, we will be asked to create an element of the path filling family, which
  -- -- --   -- should be just the same as the equality we are being asked to produce here.

  -- -- --   -- Still, for some reason I seem to have a preference for the other formulation, as it involves
  -- -- --   -- one less equality....
    

  -- -- -- Sectioned : {I : Type‚ÇÄ} {P : Poly I} (F : FillingFamily P) ‚Üí Type‚ÇÄ
  -- -- -- Sectioned {I} {P} F = {i : I} {c : Œ≥ P i} (pd : W (P // F) (i , c)) ‚Üí F (flatten F pd) c (flatten-frm F pd)

  -- -- -- -- Ah, okay, maybe the interesting case is when its a *proposition*.
  -- -- -- -- Because it seems that this is what will happen in the case of set-level objects ...
  -- -- -- StrongSectioned : {I : Type‚ÇÄ} {P : Poly I} (F : FillingFamily P) ‚Üí Type‚ÇÄ
  -- -- -- StrongSectioned {I} {P} F = {i : I} {c : Œ≥ P i} (pd : W (P // F) (i , c)) ‚Üí is-contr (F (flatten F pd) c (flatten-frm F pd))

  -- -- -- SectionedFillers : {I : Type‚ÇÄ} (P : Poly I) (F : FillingFamily P)
  -- -- --   ‚Üí Sectioned F
  -- -- --   ‚Üí FillingFamily (P // F)
  -- -- -- SectionedFillers P F œÉ {i , c} pd (w , f , x) ff =
  -- -- --   Path {A = Œ£ (Œ£ (W P i) (Œª w‚ÇÄ ‚Üí Œ£ (Frame P w‚ÇÄ c) (F w‚ÇÄ c))) (Frame (P // F) pd) }
  -- -- --     ((w , f , x) , ff)
  -- -- --     ((flatten F pd , flatten-frm F pd , œÉ pd) , bd-frame F pd)

  -- -- -- -- Right, so this is pretty huge.  What does it get you?
  -- -- -- sectioned-lemma : {I : Type‚ÇÄ} (P : Poly I) (F : FillingFamily P)
  -- -- --   ‚Üí (œÉ : Sectioned F)
  -- -- --   ‚Üí {i : I} {c : Œ≥ P i} (pd : W (P // F) (i , c)) ‚Üí is-contr (CompositeFor (SectionedFillers P F œÉ) pd)
  -- -- -- sectioned-lemma P F œÉ {i} {c} pd = has-level-in (ctr , pth)

  -- -- --   where ctr : CompositeFor (SectionedFillers P F œÉ) pd
  -- -- --         ctr = (flatten F pd , flatten-frm F pd , œÉ pd) , bd-frame F pd , idp

  -- -- --         pth : (x : CompositeFor (SectionedFillers P F œÉ) pd) ‚Üí ctr == x
  -- -- --         pth ((._ , ._ , ._) , ._ , idp) = idp

  -- -- -- conj : {I : Type‚ÇÄ} (P : Poly I) (F : FillingFamily P) (œÉ : Sectioned F)
  -- -- --   ‚Üí Sectioned (SectionedFillers P F œÉ)
  -- -- -- conj P F œÉ {i , c} {w , f , x} (lf .((i , c) , w , f , x)) = pair= (pair= w-unit {!!}) {!!}

  -- -- --   where w-unit : w == substitute F w (Œª j p ‚Üí lf j)
  -- -- --         w-unit = {!!}

  -- -- --         crl : W (P // F) (i , c)
  -- -- --         crl = nd ((w , f , x) , Œª j p ‚Üí lf j)

  -- -- --         fpth : f == flatten-frm F crl [ (Œª w‚ÇÄ ‚Üí Frame P w‚ÇÄ c) ‚Üì w-unit ]
  -- -- --         fpth = {!!}

  -- -- --         -- This one is a bit of a question mark.  I don't necessarily see
  -- -- --         -- that there should be such a path.  What links your arbitrary x to
  -- -- --         -- the chosen œÉ?
  -- -- --         spth : x == œÉ crl [ uncurry (Œª w‚ÇÄ f‚ÇÄ ‚Üí F w‚ÇÄ c f‚ÇÄ) ‚Üì pair= w-unit fpth ]
  -- -- --         spth = {!!}
          
  -- -- --         next : (f , x) == (flatten-frm F crl , œÉ crl) [ (Œª w‚ÇÄ ‚Üí Œ£ (Frame P w‚ÇÄ c) (F w‚ÇÄ c)) ‚Üì w-unit ]
  -- -- --         next = ‚Üì-Œ£-in {A = W P i} {B = Œª w‚ÇÄ ‚Üí Frame P w‚ÇÄ c} {C = Œª w‚ÇÄ f ‚Üí F w‚ÇÄ c f}
  -- -- --                       {p = w-unit} {r = f} {r' = flatten-frm F crl}
  -- -- --                       {s = x} {s' = œÉ crl}
  -- -- --                       fpth {!!} -- spth

  -- -- -- -- ‚Üì-Œ£-in : {x x' : A} {p : x == x'} {r : B x} {r' : B x'}
  -- -- -- --   {s : C x r} {s' : C x' r'}
  -- -- -- --   (q : r == r' [ B ‚Üì p ])
  -- -- -- --   ‚Üí s == s' [ uncurry C ‚Üì pair= p q ]
  -- -- -- --   ‚Üí (r , s) == (r' , s') [ (Œª x ‚Üí Œ£ (B x) (C x)) ‚Üì p ]
  -- -- -- -- ‚Üì-Œ£-in {p = idp} idp t = pair= idp t


  -- -- -- conj P F œÉ {i , c} {.(flatten F pd) , .(flatten-frm F pd) , .(œÉ pd)} (nd ((pd , .(bd-frame F pd) , idp) , Œ∫)) = pair= (pair= {!!} {!!}) {!!}

  -- -- -- -- Indeed, after path induction, this theorem looks entirely reasonable, if tedious.
  -- -- -- -- Hmmm.  But on the other hand, if feels like we will need some more hypotheses on
  -- -- -- -- œÉ, since otherwise, why should this at all be connected with x?

  -- -- -- -- SectionedDomain : {I : Type‚ÇÄ} (P : Poly I) (F : FillingFamily P)
  -- -- -- --   ‚Üí (œÉ : Sectioned F)
  -- -- -- --   ‚Üí PolyDomain (P // F)
  -- -- -- -- F (SectionedDomain P F œÉ) = SectionedFillers P F œÉ
  -- -- -- -- H (SectionedDomain P F œÉ) = SectionedDomain (P // F) (SectionedFillers P F œÉ) (conj P F œÉ)

  -- -- -- -- SectionedMonad : {I : Type‚ÇÄ} (P : Poly I) (F : FillingFamily P)
  -- -- -- --   ‚Üí (œÉ : Sectioned F)
  -- -- -- --   ‚Üí is-algebraic (SectionedDomain P F œÉ)
  -- -- -- -- is-fillable (SectionedMonad P F œÉ) = sectioned-lemma P F œÉ 
  -- -- -- -- is-coherent (SectionedMonad P F œÉ) = {!!}
  -- -- -- -- coh-algebraic (SectionedMonad P F œÉ) = SectionedMonad (P // F) (SectionedFillers P F œÉ) (conj P F œÉ)
